//! Allows caching to an SQLite file.
//! 
//! Enabled by the `caching` feature flag.

use std::sync::{Arc, Mutex};
use std::str::FromStr;
use std::cell::OnceCell;

use thiserror::Error;
use serde::{Serialize, Deserialize};
use diesel::prelude::*;

use crate::util::*;

#[allow(clippy::missing_docs_in_private_items, reason = "File is auto-generated by diesel's CLI.")]
mod schema;
pub use schema::cache;

/// An empty cache that is written when trying to connect to a file that deosn't exist.
pub const EMPTY_CACHE: &[u8] = include_bytes!("../../empty-cache.sqlite");

/// An entry in the [`cache`] table.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Queryable, Selectable)]
#[diesel(table_name = cache)]
#[diesel(check_for_backend(diesel::sqlite::Sqlite))]
pub struct CacheEntry {
    /// The ID of the entry.
    pub id: i32,
    /// The category of the entry.
    pub category: String,
    /// The key of the entry.
    pub key: String,
    /// The value of the entry.
    pub value: Option<String>
}

/// An addition to the [`cache`] table.
#[derive(Debug, PartialEq, Eq, Serialize, Insertable)]
#[diesel(table_name = cache)]
pub struct NewCacheEntry<'a> {
    /// The category of the new entry.
    pub category: &'a str,
    /// The key of the new entry.
    pub key: &'a str,
    /// The value of the new entry.
    pub value: Option<&'a str>
}

/// Convenience wrapper to contain the annoyingness of it all.
/// 
/// Internally it's an [`Arc`] of a [`Mutex`] so cloning is O(1) and sharing immutable references is not a problem.
#[derive(Debug, Clone)]
pub struct CacheHandler(pub Arc<Mutex<InnerCacheHandler>>);

/// The internals of [`CacheHandler`] that handles lazily connecting.
pub struct InnerCacheHandler {
    /// The path being connected to.
    path: String,
    /// The actual [`SqliteConnection`].
    connection: OnceCell<SqliteConnection>
}

impl ::core::fmt::Debug for InnerCacheHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        f.debug_struct("InnerCacheHandler")
            .field("path", &self.path)
            .field("connection", if self.connection.get().is_some() {&"OnceCell(..)"} else {&"OnceCell(<uninit>)"})
            .finish()
    }
}

impl FromStr for CacheHandler {
    type Err = <InnerCacheHandler as FromStr>::Err;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        InnerCacheHandler::from_str(s).map(Into::into)
    }
}

impl<T: Into<InnerCacheHandler>> From<T> for CacheHandler {
    fn from(value: T) -> Self {
        Self(Arc::new(Mutex::new(value.into())))
    }
}

impl FromStr for InnerCacheHandler {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self::from(s))
    }
}

impl From<&str> for InnerCacheHandler {
    fn from(value: &str) -> Self {
        value.to_string().into()
    }
}

impl From<String> for InnerCacheHandler {
    fn from(value: String) -> Self {
        InnerCacheHandler { path: value, connection: OnceCell::new() }
    }
}

/// The enum of errors [`CacheHandler::read_from_cache`] and [`InnerCacheHandler::read_from_cache`] can return.
#[derive(Debug, Error)]
pub enum ReadFromCacheError {
    /// Returned when the inner [`Mutex`] is poisoned.
    #[error("{0}")]
    MutexPoisonError(String),
    /// Returned when a [`diesel::result::Error`] is encountered.
    #[error(transparent)]
    DieselError(#[from] diesel::result::Error),
    /// Returned when a [`ConnectCacheError`] is encountered.
    #[error(transparent)]
    ConnectCacheError(#[from] ConnectCacheError)
}

/// The enum of errors [`CacheHandler::write_to_cache`] and [`InnerCacheHandler::write_to_cache`] can return.
#[derive(Debug, Error)]
pub enum WriteToCacheError {
    /// Returned when the inner [`Mutex`] is poisoned.
    #[error("{0}")]
    MutexPoisonError(String),
    /// Returned when a [`diesel::result::Error`] is encountered.
    #[error(transparent)]
    DieselError(#[from] diesel::result::Error),
    /// Returned when a [`ConnectCacheError`] is encountered.
    #[error(transparent)]
    ConnectCacheError(#[from] ConnectCacheError)
}

impl CacheHandler {
    /// Reads a string from the cache.
    /// # Errors
    /// If the call to [`Mutex::lock`] returns an error, that error is returned.
    /// 
    /// If the call to [`InnerCacheHandler::read_from_cache`] returns an error, that error is returned.
    pub fn read_from_cache(&self, category: &str, key: &str) -> Result<Option<Option<String>>, ReadFromCacheError> {
        self.0.lock().map_err(|e| ReadFromCacheError::MutexPoisonError(e.to_string()))?.read_from_cache(category, key)
    }

    /// Writes a string to the cache.
    /// # Errors
    /// If the call to [`Mutex::lock`] returns an error, that error is returned.
    /// 
    /// If the call to [`InnerCacheHandler::write_to_cache`] returns an error, that error is returned.
    pub fn write_to_cache(&self, category: &str, key: &str, value: Option<&str>) -> Result<(), WriteToCacheError> {
        self.0.lock().map_err(|e| WriteToCacheError::MutexPoisonError(e.to_string()))?.write_to_cache(category, key, value)
    }
}

/// The enum of errors [`InnerCacheHandler::connect`] can return.
#[derive(Debug, Error)]
pub enum ConnectCacheError {
    /// Returned when a [`diesel::ConnectionError`] is encountered.
    #[error(transparent)]
    ConnectionError(#[from] diesel::ConnectionError),
    /// Returned when a [`std::io::Error`] is encountered.
    #[error(transparent)]
    IoError(#[from] std::io::Error),
}

impl InnerCacheHandler {
    /// Returns the path being connected to.
    pub fn path(&self) -> &str {
        &self.path
    }

    /// If connected, returns a mutable reference to the connection.
    pub fn connection(&mut self) -> Option<&mut SqliteConnection> {
        self.connection.get_mut()
    }

    /// If the path is a file and doesn't exist, writes [`EMPTY_CACHE`] to the path.
    /// 
    /// If the path is `:memory:` or starts with `file://` (for an explicit opt-out), the file is not created.
    /// 
    /// If unconnected, connect to the path then return the connection.
    /// 
    /// If connected, return the connection.
    /// # Errors
    /// If the call to [`std::fs::exists`] returns an error, that error is returned.
    /// 
    /// If the call to [`std::fs::write`] returns an error, that error is returned.
    /// 
    /// If the call to [`SqliteConnection::establish`] returns an error, that error is returned.
    #[allow(clippy::missing_panics_doc, reason = "Doesn't panic, but should be replaced with OnceCell::get_or_try_init once that's stable.")]
    pub fn connect(&mut self) -> Result<&mut SqliteConnection, ConnectCacheError> {
        debug!(InnerCacheHandler::connect, self);
        if self.path!=":memory:" && !self.path.starts_with("file://") && !std::fs::exists(&self.path)? {
            std::fs::write(&self.path, EMPTY_CACHE)?;
        }
        if self.connection.get().is_none() {
            self.connection.set(SqliteConnection::establish(&self.path)?).map_err(|_| ()).expect("The connection to have just been confirmed unset.");
        }
        Ok(self.connection.get_mut().expect("The connection to have just been set."))
    }

    /// Disconnects and drops the contained [`SqliteConnection`].
    pub fn disconnect(&mut self) {
        let _ = self.connection.take();
    }

    /// Reads a string from the cache.
    /// 
    /// The outer [`Option`] says if there's a matching cache entry.
    /// 
    /// The inner [`Option`] is the cache entry.
    /// # Errors
    /// If the call to [`RunQueryDsl::get_result`] returns an error, that error is returned.
    pub fn read_from_cache(&mut self, category: &str, key: &str) -> Result<Option<Option<String>>, ReadFromCacheError> {
        debug!(CacheHandler::read_from_cache, self, category, key);
        Ok(cache::dsl::cache
            .filter(cache::dsl::category.eq(category))
            .filter(cache::dsl::key.eq(key))
            .limit(1)
            .select(CacheEntry::as_select())
            .load(self.connect()?)?
            .first()
            .map(|cache_entry| cache_entry.value.to_owned()))
    }

    /// Writes a string to the cache.
    /// 
    /// Note that this doesn't check if the corresponding `key` and `value` are already present in a cache entry.
    /// 
    /// Not checking yourself could result in [`Self::read_from_cache`] not returning the written value.
    /// # Errors
    /// If the call to [`RunQueryDsl::get_result`] returns an error, that error is returned.
    pub fn write_to_cache(&mut self, category: &str, key: &str, value: Option<&str>) -> Result<(), WriteToCacheError> {
        debug!(CacheHandler::write_to_cache, self, category, key, value);
        diesel::insert_into(cache::table)
            .values(&NewCacheEntry {category, key, value})
            .returning(CacheEntry::as_returning())
            .get_result(self.connect()?)?;
        Ok(())
    }
}

impl From<InnerCacheHandler> for (String, OnceCell<SqliteConnection>) {
    fn from(value: InnerCacheHandler) -> Self {
        (value.path, value.connection)
    }
}
